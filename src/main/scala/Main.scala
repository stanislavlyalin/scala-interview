import scala.collection.immutable.{HashMap, HashSet}

object Main {
  def main(args: Array[String]): Unit = {

    // HashSet и HashMap

    // Это типы данных, которые позволяют эффективно вставлять и извлекать значения из Set / Map
    // Для реализации используется структура Hash Array Mapped Trie (HAMT)
    // Принцип действия:
    // Вставляемое значение (например, 1), хешируется и разбивается на части, например, по 2 бита
    // (на практике 5 бит - 32 ячейки на одном уровне дерева)
    // Далее идём по частям хеша и вставляем в соответствующие узлы (ячейки). Если узла нет, он создаётся.
    // Пример:

    // Изначально
    // Empty HashSet:
    // {}

    // Нам нужно вставить значение `1`. Например, его хеш = 0001. Разбиваем на 2 части: 00 и 01
    // Двумя битами можно закодировать 4 ячейки, поэтому на первом уровне дерева массив из 4 элементов
    // По индексу 00 ничего нет, поэтому создаём новый узел также из 4 элементов
    // Root:
    // [ Node , _ , _ , _ ]

    // Затем в этот новый узел вставляем элемент по индексу 01. Получается:
    // Root:
    //[ Node , _ , _ , _ ]
    //    |
    //    v
    // Node at Root[0]:
    // [ _ , 1 , _ , _ ]

    // При извлечении аналогичный процесс. Считаем хеш, разбиваем на части, спускаемся по дереву и смотрим, есть ли
    // такой элемент

    // Это гораздо эффективнее. Сложность вместо O(N) будет O(1), т.к. взятие по индексу из массива - константно

    // Примеры использования HashSet и HashMap из стандартной библиотеки

    val set = HashSet(1, 2, 3, 4, 5)
    val newSet = set + 6
    val removedSet = set - 3

    println(set) // Output: HashSet(5, 1, 2, 3, 4)
    println(newSet) // Output: HashSet(5, 1, 6, 2, 3, 4)
    println(removedSet) // Output: HashSet(5, 1, 2, 4)

    val map = HashMap("a" -> 1, "b" -> 2, "c" -> 3)
    val newMap = map + ("d" -> 4)
    val removedMap = map - "b"

    println(map)        // Output: HashMap(a -> 1, b -> 2, c -> 3)
    println(newMap)     // Output: HashMap(a -> 1, b -> 2, c -> 3, d -> 4)
    println(removedMap) // Output: HashMap(a -> 1, c -> 3)
  }
}
